// exportFunctions.js
import Papa from "papaparse";
import { saveAs } from "file-saver";
import jsPDF from "jspdf";
import "jspdf-autotable";
import MainLogo from "../../images/withText.png";

export const exportToCSV = (
  headers,
  rows,
  filename = "report.csv",
  user = "Unknown",
  title = "Report",
  startDate = null,
  endDate = null
) => {
  const timestamp = new Date().toLocaleString();

  // Format date range if provided
  let dateRange = "";
  if (startDate || endDate) {
    const formatDate = (date) => {
      if (!date) return "";
      const d = new Date(date);
      return d.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric",
      });
    };

    // If both dates are the same, display single date with "From"
    if (startDate && endDate && startDate === endDate) {
      dateRange = `From ${formatDate(startDate)}`;
    } else if (startDate && endDate) {
      dateRange = `From ${formatDate(startDate)} To ${formatDate(endDate)}`;
    } else if (startDate && !endDate) {
      dateRange = `From ${formatDate(startDate)}`;
    } else if (!startDate && endDate) {
      dateRange = `To ${formatDate(endDate)}`;
    }
  }

  // Clean and prepare data for CSV export
  const cleanDataForCSV = (data) => {
    return data.map(row => 
      row.map(cell => {
        if (typeof cell === 'string') {
          // Replace any existing ± with ₱
          return cell.replace(/±/g, '₱');
        }
        return cell;
      })
    );
  };

  const cleanedHeaders = cleanDataForCSV([headers])[0];
  const cleanedRows = cleanDataForCSV(rows);

  const data = [
    ["TicketEase"],
    [title],
    ...(dateRange ? [[dateRange]] : []),
    [],
    cleanedHeaders,
    ...cleanedRows,
    [],
    [`Exported By: ${user}`],
    [`Timestamp: ${timestamp}`],
    [],
    ["Generated by TicketEase"],
  ];

  const csv = Papa.unparse(data, {
    quotes: true,
    quoteChar: '"',
    escapeChar: '"',
    delimiter: ",",
    header: false,
    newline: "\r\n", // Windows line endings for better compatibility
  });

  // Use proper encoding with BOM for UTF-8
  const BOM = "\uFEFF";
  const blob = new Blob([BOM + csv], { 
    type: "text/csv;charset=utf-8;" 
  });
  
  if (!filename.endsWith(".csv")) filename += ".csv";
  saveAs(blob, filename);
};

export const exportToPDF = (
  headers,
  rows,
  title = "Report",
  filename = "report.pdf",
  user = "Unknown",
  startDate = null,
  endDate = null
) => {
  const timestamp = new Date().toLocaleString();
  const doc = new jsPDF("landscape");
  const pageWidth = doc.internal.pageSize.getWidth();
  const pageHeight = doc.internal.pageSize.getHeight();

  const logoWidth = 40;
  const logoHeight = 40;
  const logoX = (pageWidth - logoWidth) / 2;
  doc.addImage(MainLogo, "PNG", logoX, 10, logoWidth, logoHeight);

  doc.setFontSize(16);
  doc.text(title, pageWidth / 2, 60, { align: "center" });

  // Add date range if provided
  let startY = 70;
  if (startDate || endDate) {
    const formatDate = (date) => {
      if (!date) return "";
      const d = new Date(date);
      return d.toLocaleDateString("en-US", {
        year: "numeric",
        month: "long",
        day: "numeric",
      });
    };

    let dateRange = "";
    // If both dates are the same, display single date with "From"
    if (startDate && endDate && startDate === endDate) {
      dateRange = `From ${formatDate(startDate)}`;
    } else if (startDate && endDate) {
      dateRange = `From ${formatDate(startDate)} To ${formatDate(endDate)}`;
    } else if (startDate && !endDate) {
      dateRange = `From ${formatDate(startDate)}`;
    } else if (!startDate && endDate) {
      dateRange = `To ${formatDate(endDate)}`;
    }

    doc.setFontSize(12);
    doc.text(dateRange, pageWidth / 2, 68, { align: "center" });
    startY = 76;
  }

  // Clean data for PDF export - replace ± with ₱
  const cleanDataForPDF = (data) => {
    return data.map(row => 
      row.map(cell => {
        if (typeof cell === 'string') {
          return cell.replace(/±/g, '₱');
        }
        return cell;
      })
    );
  };

  const cleanedHeaders = cleanDataForPDF([headers])[0];
  const cleanedRows = cleanDataForPDF(rows);

  doc.autoTable({
    head: [cleanedHeaders],
    body: cleanedRows,
    startY: startY,
    theme: "grid",
    margin: { left: 14, right: 14, top: 20, bottom: 35 },
    headStyles: { 
      fillColor: [54, 76, 110], 
      textColor: [255, 255, 255],
      fontStyle: 'bold',
      fontSize: 10,
      halign: 'center'
    },
    bodyStyles: { 
      fontSize: 9,
      cellPadding: 2,
      valign: 'middle'
    },
    styles: {
      font: 'helvetica',
      fontStyle: 'normal',
      overflow: 'linebreak',
      cellWidth: 'auto',
      minCellHeight: 8
    },
    columnStyles: {
      0: { cellWidth: 'auto' },
      1: { cellWidth: 'auto' },
      2: { cellWidth: 'auto' },
      3: { cellWidth: 'auto' },
      4: { cellWidth: 'auto' },
      5: { cellWidth: 'auto' },
      6: { cellWidth: 'auto' },
      7: { cellWidth: 'auto' },
      8: { cellWidth: 'auto' }
    },
    tableWidth: 'auto',
    didDrawPage: (data) => {
      // Page number at top right
      const pageCount = doc.internal.getNumberOfPages();
      const currentPage = doc.internal.getCurrentPageInfo().pageNumber;
      
      doc.setFontSize(10);
      doc.setTextColor(60, 60, 60);
      doc.setFont('helvetica', 'normal');
      doc.text(`Page ${currentPage} of ${pageCount}`, pageWidth - 14, 15, {
        align: "right",
      });
      
      // Footer on every page
      const footerY = pageHeight - 20;
      
      // Set font size for footer
      doc.setFontSize(10);
      doc.setTextColor(60, 60, 60);
      
      // Left side - Exported by (bold label)
      doc.setFont('helvetica', 'bold');
      const exportByLabel = 'Exported By:';
      const exportByLabelWidth = doc.getTextWidth(exportByLabel);
      doc.text(exportByLabel, 14, footerY);
      
      doc.setFont('helvetica', 'normal');
      doc.text(user, 14 + exportByLabelWidth + 1, footerY);
      
      // Right side - Timestamp (bold label)
      doc.setFont('helvetica', 'bold');
      const timestampLabel = 'Timestamp:';
      const timestampLabelWidth = doc.getTextWidth(timestampLabel);
      const timestampValueWidth = doc.getTextWidth(timestamp);
      const totalTimestampWidth = timestampLabelWidth + 1 + timestampValueWidth;
      
      doc.text(timestampLabel, pageWidth - 14 - totalTimestampWidth, footerY);
      
      doc.setFont('helvetica', 'normal');
      doc.text(timestamp, pageWidth - 14 - timestampValueWidth, footerY);

      // Bottom center - Generated by
      doc.setFont('helvetica', 'normal');
      doc.setFontSize(8);
      doc.setTextColor(100, 100, 100);
      doc.text("Generated by TicketEase", pageWidth / 2, pageHeight - 8, {
        align: "center",
      });
      
      // Reset text color and font
      doc.setTextColor(0, 0, 0);
      doc.setFont('helvetica', 'normal');
    },
  });

  if (!filename.endsWith(".pdf")) filename += ".pdf";
  doc.save(filename);
};